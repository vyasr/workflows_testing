name: Issue Release Field Scheduled Sync

on:
  schedule:
    - cron: '0 * * * *'
  # Allow manual triggering for testing
  workflow_dispatch:

jobs:
  sync-release-fields:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Restore priority cache
        id: cache-priority
        uses: actions/cache@v4
        with:
          path: .github/priority-cache.json
          key: priority-cache-${{ github.run_id }}
          restore-keys: |
            priority-cache-

      - name: Sync release fields for all project issues
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECT_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const fs = require('fs');
            const path = require('path');

            // Only operate on this specific project
            const TARGET_PROJECT_ID = 'PVT_kwHOABd4dc4BHWeu';

            console.log('Starting scheduled release field sync...');

            try {
              // Load previous priority cache
              const cacheFile = '.github/priority-cache.json';
              let previousPriorities = {};

              if (fs.existsSync(cacheFile)) {
                const cacheContent = fs.readFileSync(cacheFile, 'utf8');
                previousPriorities = JSON.parse(cacheContent);
                console.log(`Loaded ${Object.keys(previousPriorities).length} cached priority values`);
              } else {
                console.log('No previous priority cache found, treating all as new');
              }

              // Current priorities (will be saved at the end)
              const currentPriorities = {};

              // Read VERSION file to get current release
              const versionContent = fs.readFileSync('VERSION', 'utf8').trim();
              const versionParts = versionContent.split('.');
              const currentRelease = `${versionParts[0]}.${versionParts[1]}`;
              console.log(`Current release from VERSION: ${currentRelease}`);

              // Get all open issues in the repository
              const { data: issues } = await github.rest.issues.listForRepo({
                owner,
                repo,
                state: 'open',
                per_page: 100
              });

              console.log(`Found ${issues.length} open issues to check`);

              let updatedCount = 0;
              let skippedCount = 0;
              let errorCount = 0;

              for (const issue of issues) {
                // Skip pull requests (they have their own workflow)
                if (issue.pull_request) {
                  continue;
                }

                const issueNumber = issue.number;
                const issueNodeId = issue.node_id;

                console.log(`\nChecking issue #${issueNumber}`);

                try {
                  // Query to get project items for this issue
                  const projectItemsQuery = `
                    query($nodeId: ID!) {
                      node(id: $nodeId) {
                        ... on Issue {
                          projectItems(first: 10) {
                            nodes {
                              id
                              project {
                                id
                                title
                              }
                              fieldValues(first: 20) {
                                nodes {
                                  ... on ProjectV2ItemFieldSingleSelectValue {
                                    name
                                    field {
                                      ... on ProjectV2SingleSelectField {
                                        id
                                        name
                                      }
                                    }
                                  }
                                  ... on ProjectV2ItemFieldTextValue {
                                    text
                                    field {
                                      ... on ProjectV2Field {
                                        id
                                        name
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  `;

                  const projectItemsResult = await github.graphql(projectItemsQuery, {
                    nodeId: issueNodeId
                  });

                  const projectItems = projectItemsResult.node?.projectItems?.nodes || [];

                  if (projectItems.length === 0) {
                    console.log(`Issue #${issueNumber} is not in any project, skipping`);
                    skippedCount++;
                    continue;
                  }

                  // Process each project the issue is in
                  for (const projectItem of projectItems) {
                    const projectId = projectItem.project.id;
                    const projectTitle = projectItem.project.title;
                    const itemId = projectItem.id;

                    // Skip if not the target project
                    if (projectId !== TARGET_PROJECT_ID) {
                      continue;
                    }

                    console.log(`  Processing project: ${projectTitle}`);

                    // Find Priority and Release field values
                    let priorityValue = null;
                    let currentReleaseValue = null;
                    let releaseFieldId = null;

                    for (const fieldValue of projectItem.fieldValues.nodes) {
                      if (fieldValue.field?.name === 'Priority') {
                        priorityValue = fieldValue.name;
                        console.log(`    Found Priority: ${priorityValue}`);
                      }
                      if (fieldValue.field?.name === 'Release') {
                        releaseFieldId = fieldValue.field.id;
                        currentReleaseValue = fieldValue.text || fieldValue.name;
                        console.log(`    Found Release: ${currentReleaseValue}`);
                      }
                    }

                    // Query project for Release field details (type and options)
                    let releaseFieldType = null;
                    let releaseFieldOptions = [];

                    if (!releaseFieldId) {
                      console.log('    Release field not found on item, querying project fields');
                    }

                    const projectFieldsQuery = `
                      query($projectId: ID!) {
                        node(id: $projectId) {
                          ... on ProjectV2 {
                            fields(first: 20) {
                              nodes {
                                ... on ProjectV2Field {
                                  id
                                  name
                                  dataType
                                }
                                ... on ProjectV2SingleSelectField {
                                  id
                                  name
                                  dataType
                                  options {
                                    id
                                    name
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    `;

                    const projectFieldsResult = await github.graphql(projectFieldsQuery, {
                      projectId: projectId
                    });

                    const fields = projectFieldsResult.node?.fields?.nodes || [];
                    const releaseField = fields.find(f => f.name === 'Release');

                    if (releaseField) {
                      if (!releaseFieldId) {
                        releaseFieldId = releaseField.id;
                        console.log(`    Found Release field ID from project: ${releaseFieldId}`);
                      }
                      releaseFieldType = releaseField.dataType;
                      releaseFieldOptions = releaseField.options || [];
                      console.log(`    Release field type: ${releaseFieldType}`);
                      if (releaseFieldOptions.length > 0) {
                        console.log(`    Available options: ${releaseFieldOptions.map(o => o.name).join(', ')}`);
                      }
                    }

                    // Skip if no Priority value
                    if (!priorityValue) {
                      console.log(`    No Priority value found, skipping`);
                      continue;
                    }

                    // Store current priority for this issue
                    const cacheKey = `${projectId}:${issueNumber}`;
                    currentPriorities[cacheKey] = priorityValue;

                    // Skip if no Release field
                    if (!releaseFieldId) {
                      console.log(`    No Release field found in project, skipping`);
                      continue;
                    }

                    // Check if Priority has changed since last run
                    const previousPriority = previousPriorities[cacheKey];
                    const priorityChanged = previousPriority !== priorityValue;

                    if (!priorityChanged) {
                      console.log(`    Priority unchanged (${priorityValue}), skipping Release update (preserving manual changes)`);
                      continue;
                    }

                    console.log(`    Priority changed: "${previousPriority || '(new)'}" → "${priorityValue}"`);

                    // Determine what the release value should be based on priority
                    let expectedReleaseValue;
                    if (priorityValue === 'P0' || priorityValue === 'P1') {
                      expectedReleaseValue = currentRelease;
                    } else if (priorityValue.match(/^P[2-9]$/) || priorityValue.match(/^P\d{2,}$/)) {
                      expectedReleaseValue = 'Backlog';
                    } else {
                      console.log(`    Unknown priority format: ${priorityValue}, skipping`);
                      continue;
                    }

                    console.log(`    Updating Release field to: "${expectedReleaseValue}"`);

                    // Update the Release field based on field type
                    if (releaseFieldType === 'SINGLE_SELECT') {
                      // For single select fields, find the option ID
                      const option = releaseFieldOptions.find(o => o.name === expectedReleaseValue);

                      if (!option) {
                        console.log(`    ERROR: Option "${expectedReleaseValue}" not found in Release field options`);
                        console.log(`    Available options: ${releaseFieldOptions.map(o => o.name).join(', ')}`);

                        await github.rest.issues.createComment({
                          owner,
                          repo,
                          issue_number: issueNumber,
                          body: `⚠️ **Release Automation Error**: Cannot set Release to "${expectedReleaseValue}" - this option does not exist in the project.\n\nAvailable options: ${releaseFieldOptions.map(o => o.name).join(', ')}\n\nPlease add "${expectedReleaseValue}" as an option to the Release field in your project.`
                        });
                        continue;
                      }

                      console.log(`    Using option ID: ${option.id} for "${expectedReleaseValue}"`);

                      const updateMutation = `
                        mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                          updateProjectV2ItemFieldValue(
                            input: {
                              projectId: $projectId
                              itemId: $itemId
                              fieldId: $fieldId
                              value: { singleSelectOptionId: $optionId }
                            }
                          ) {
                            projectV2Item {
                              id
                            }
                          }
                        }
                      `;

                      await github.graphql(updateMutation, {
                        projectId: projectId,
                        itemId: itemId,
                        fieldId: releaseFieldId,
                        optionId: option.id
                      });
                    } else {
                      // For text fields, use text value
                      const updateMutation = `
                        mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $value: String!) {
                          updateProjectV2ItemFieldValue(
                            input: {
                              projectId: $projectId
                              itemId: $itemId
                              fieldId: $fieldId
                              value: { text: $value }
                            }
                          ) {
                            projectV2Item {
                              id
                            }
                          }
                        }
                      `;

                      await github.graphql(updateMutation, {
                        projectId: projectId,
                        itemId: itemId,
                        fieldId: releaseFieldId,
                        value: expectedReleaseValue
                      });
                    }

                    console.log(`    ✓ Successfully updated Release field to "${expectedReleaseValue}"`);
                    updatedCount++;
                  }

                } catch (error) {
                  console.error(`Error processing issue #${issueNumber}:`, error.message);
                  errorCount++;
                  // Continue with next issue rather than failing the entire workflow
                }
              }

              // Save current priorities cache for next run
              const cacheDir = '.github';
              if (!fs.existsSync(cacheDir)) {
                fs.mkdirSync(cacheDir, { recursive: true });
              }
              fs.writeFileSync(cacheFile, JSON.stringify(currentPriorities, null, 2));
              console.log(`\nSaved ${Object.keys(currentPriorities).length} priority values to cache`);

              // Summary
              console.log('\n=== Sync Summary ===');
              console.log(`Total open issues checked: ${issues.length}`);
              console.log(`Issues updated: ${updatedCount}`);
              console.log(`Issues skipped (not in project or no Priority): ${skippedCount}`);
              console.log(`Errors encountered: ${errorCount}`);

            } catch (error) {
              console.error('Fatal error in scheduled sync:', error);
              throw error;
            }
